#' View (and save) `test_runtests()` output
#'
#' Use `view_test_results()` to preview test results generated by `save_test_results()`
#' (saving should only ever be done in a GHA workflow).
#'
#' @param test_runtests_output output from `test_runtests()`.
#' @param gha_branch_name an identifier determined by the GHA workflow
#' @param pr_number the pull request number.
#' @param username the username of the github profile.
#' @rdname test-results
#' @export
save_test_results <- function(test_runtests_output, gha_branch_name, pr_number, username) {
  if (!inherits(test_runtests_output, "shinycoreci_runtests")) {
    stop("test_runtests_output must be an object returned by test_runtests()", call. = FALSE)
  }
  # Make the results serializable (result contain conditions, data frames, etc)
  test_runtests_output$result <- vapply(
    test_runtests_output$result,
    function(x) {
      paste0(utils::capture.output({print(x)}), collapse = "\n")
    },
    character(1)
  )

  # Get the app names from the test files
  app_dirs <- dirname(dirname(test_runtests_output$test_path))
  test_runtests_output$app_name <- basename(app_dirs)

  # Attach some other meta-data to the test results
  val <- list(
    results = test_runtests_output,
    platform = platform(),
    r_version = r_version_short(),
    session = unclass(sessioninfo::platform_info()),
    gha_image_version = gha_image_version(),
    sys_info = paste0(utils::capture.output({write_sysinfo()}), collapse = "\n"),
    branch_name = git_branch(app_dirs[1]),
    branch_sha = git_sha(app_dirs[1]),
    pr_number = pr_number,
    username = username,
    gha_branch_name = gha_branch_name,
    version = 1
  )

  # Root shinycoreci-apps directory
  root_dir <- unique(dirname(dirname(app_dirs)))
  # Where the results will be placed
  results_dir <- file.path(root_dir, "_test_results")
  dir.create(results_dir, showWarnings = FALSE)
  results_file <- file.path(results_dir, paste0(gha_branch_name, ".json"))

  cat(jsonlite::toJSON(val, auto_unbox = TRUE), file = results_file)
  invisible(val)
}



#' @rdname test-results
#' @inheritParams test_runtests
#' @export
view_test_results <- function(dir = ".") {
  validate_core_pkgs()

  repo_dir <- normalizePath(dir, mustWork = TRUE)
  if ("shinycoreci-apps" != basename(repo_dir)) {
    stop("This function must be called from the shinycoreci-apps repo")
  }

  withr::with_namespace("shiny", {
    withr::with_namespace("htmltools", {

      banner <- div(
        style = "display:flex; justify-content:center; gap:1rem; margin-top: 1rem",
        div("Showing", class = "lead text-large"),
        tagAppendAttributes(uiOutput("platform"), style = "width:200px"),
        div("results between ", class = "lead text-large"),
        tagAppendAttributes(uiOutput("date_start"), style = "width:150px"),
        div(" and ", class = "lead text-large"),
        tagAppendAttributes(uiOutput("date_end"), style = "width:150px"),
        actionButton(
          "fetch_results", "Fetch results",
          icon = icon("cloud-download-alt"),
          class = "btn-primary btn-sm",
          style = "height:2.5rem"
        )
      )

      theme <- bslib::bs_theme(base_font = bslib::font_google("Prompt"))
      ui <- fluidPage(
        theme = bslib::bs_add_rules(theme, ".nav-pills { @extend .justify-content-center; }"),
        tags$head(tags$style(".dataTables_filter {display: none}")),
        div(
          style = "display:flex; flex-direction: column; align-items: center",
          banner,
          div(
            style = "width: 60%",
            DT::dataTableOutput("app_status_table")
          )
        )
      )

      server <- function(input, output, session) {

        log_files <- reactive({
          if (isTRUE(input$fetch_results > 1)) {
            git_cmd(repo_dir, "git fetch origin _test_results:_test_results")
            try({
              git_cmd(repo_dir, "git checkout _test_results -- _test_results/")
              git_cmd(repo_dir, "git reset _test_results/")
            })
          }
          withr::with_dir(repo_dir, normalizePath(Sys.glob("_test_results/*.json"), mustWork = TRUE))
        })

        log_dates <- reactive({
          as.Date(
            strextract(basename(log_files()), "[0-9]{4}_[0-9]{2}_[0-9]{2}"),
            format = "%Y_%m_%d"
          )
        })

        logs <- reactive({
          req(rng <- c(input$date_start, input$date_end))
          rng <- as.Date(rng)
          idx <- dplyr::between(
            log_dates(),
            left = min(rng),
            right = max(rng)
          )
          test_results(log_files()[idx])
        })

        output$platform <- renderUI({
          choices <- c("All platforms" = "all", unique(logs()$platform))
          selectInput("platform", NULL, choices = choices)
        })

        output$date_start <- renderUI({
          rng <- range(log_dates())
          dateInput(
            "date_start", NULL, value = rng[2], min = rng[1], max = rng[2]
          )
        })

        output$date_end <- renderUI({
          rng <- range(log_dates())
          dateInput(
            "date_end", NULL, value = rng[2], min = rng[1], max = rng[2]
          )
        })

        logs_summary <- reactive({
          req(input$platform)

          d <- logs()
          if (!identical(input$platform, "all")) {
            d <- dplyr::filter(d, platform %in% input$platform)
          }
          d %>%
            dplyr::count(app_name, status, name = "n") %>%
            tidyr::spread(status, n, fill = 0) %>%
            dplyr::arrange(desc(fail)) %>%
            dplyr::select(
              App = app_name, Failures = fail, Pass = pass,
              `Can't install` = can_not_install,
              `No Results` = did_not_return_result
            )
        })

        output$app_status_table <- DT::renderDataTable({
          DT::datatable(
            logs_summary(),
            rownames = FALSE,
            selection = "single",
            filter = "top",
            fillContainer = TRUE,
            options = list(
              paging = FALSE, #searching = FALSE,
              scrollY = "85vh"
            )
          )
        })

        selected_app <- reactive({
          cell <- input$app_status_table_cell_clicked
          if (length(cell) > 0) {
            logs_summary()[cell$row, "App", drop = TRUE]
          }
        })

        app_logs <- reactive({
          req(selected_app())

          dplyr::filter(
            logs(),
            app_name %in% selected_app(),
            status %in% c("fail", "can_not_install")
          )
        })

        selected_app_logs <- reactive({
          req(input$logs_date)
          dplyr::filter(app_logs(), date == as.Date(input$logs_date))
        })

        observeEvent(input$app_status_table_cell_clicked, {

          logs <- app_logs()
          log_dates <- sort(unique(logs$date), decreasing = TRUE)

          # TODO: save GHA job id and create a hyperlink to
          # https://github.com/rstudio/shinycoreci-apps/runs/{job_id}
          # Better yet, can we link to either the build log or test source code?
          modal <- modalDialog(
            title = paste(selected_app(), "failure details"),
            size = "l",
            easyClose = TRUE,
            tabsetPanel(
              tabPanel(
                "Daily details",
                div(
                  style = "display:flex; justify-content:center; gap:1rem",
                  "Failure logs from:",
                  selectInput(
                    "logs_date", NULL, choices = log_dates
                  )
                ),
                uiOutput("logs_report")
              ),
              tabPanel("Timeline", uiOutput("timeline")),
              type = "pills",
              header = br()
            )
          )

          showModal(modal)
        })

        output$timeline <- renderUI({
          validate(need(
            nrow(app_logs()) > 1,
            "No failures to show for this app"
          ))

          withr::with_namespace(
            "plotly", {

              panel <- . %>%
                plot_ly(height = 700) %>%
                add_bars(
                  x = ~date, y = ~n, color = ~paste("R", r_version),
                  legendgroup = ~r_version,
                  showlegend = ~identical(unique(os), "Linux")
                ) %>%
                add_annotations(
                  text = ~unique(os), showarrow = FALSE,
                  x = 0.5, y = 1, yref = "paper", xref = "paper",
                  yanchor = "bottom", font = list(size = 15),
                  yshift = -3
                ) %>%
                layout(
                  showlegend = FALSE,
                  barmode = "stack",
                  shapes = list(
                    type = "rect",
                    x0 = 0, x1 = 1, xref = "paper",
                    y0 = 0, y1 = 16, yref = "paper",
                    yanchor = 1, ysizemode = "pixel",
                    fillcolor = toRGB("gray80"),
                    line = list(color = "transparent")
                  )
                )

              app_logs() %>%
                dplyr::count(date, platform) %>%
                tidyr::separate(platform, c("os", "r_version"), sep = "-") %>%
                dplyr::group_by(os) %>%
                dplyr::do(p = panel(.)) %>%
                subplot(nrows = NROW(.), shareX = TRUE) %>%
                layout(
                  font = list(family = "Prompt", size = 14),
                  showlegend = TRUE, hovermode = "x",
                  yaxis2 = list(title = "Number of failures"),
                  xaxis = list(title = ""),
                  legend = list(orientation = "h", x = 1, xanchor = "right")
                ) %>%
                config(displayModeBar = FALSE)
            }
          )
        })

        output$logs_report <- renderUI({
          req(input$logs_date)

          logs <- selected_app_logs()
          logs <- split(logs, logs$platform)

          tagList(
            !!!Map(
              logs, names(logs),
              f = function(x, y) {
                res <- paste(x$result, collapse = "\n")
                tags$details(
                  open = NA,
                  tags$summary(y),
                  tags$code(tags$pre(res))
                )
              }
            )
          )
        })

      }

      shinyApp(ui, server)

    })
  })
}

test_results <- function(files) {
  results <- lapply(files, test_results_import)
  dplyr::bind_rows(results) %>%
    tibble::as_tibble() %>%
    dplyr::mutate(gha_branch = gha_branch_name) %>%
    tidyr::separate_("gha_branch_name", c("gha", "sha", "time", "r_version", "platform"), sep = "-") %>%
    dplyr::select(-gha) %>%
    dplyr::mutate(
      platform = paste(platform, r_version, sep = "-"),
      time = as.POSIXct(time, format = "%Y_%m_%d_%H_%M"),
      date = as.Date(time),
      sha = paste0(branch_name, "@", sha)
    ) %>%
    dplyr::arrange(dplyr::desc(time))
}

test_results_import <- function(f) {
  json <- jsonlite::fromJSON(f)
  json$results$gha_branch_name <- json$gha_branch_name
  json$results$branch_name <- json$branch_name
  json$results
}

utils::globalVariables(c("gha", "gha_branch_name", "time", "branch_name", "sha", "r_version", "status", "test_path", "n", "cant_install", ".", "html"))
